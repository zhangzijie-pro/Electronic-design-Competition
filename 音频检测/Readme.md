# 用FFT输出的TOP3频率序号分类音乐和语音

## 文件构成
- data 文件夹：存放FFT序号文件
- - music 文件夹：存放音乐FFT序号文件
- - voice 文件夹：存放语音FFT序号文件
- tmp 文件夹：存放原始FFT文件
- proc_data.py：处理原始FFT文件，生成FFT序号文件
- model.py：定义两层分类模型
- train.py：训练模型
- val.py：验证模型
- model.txt：训练好的模型参数
- calc.c：用于计算FFT序号的C语言程序
- README.md：本文件

**注：** 重点关注calc.c里的伪码

## 数据准备
以原始FFT文件"卡农_2.txt"为例，相邻三次FFT输出的最大值序号分别为：
```
Max: 1.147510 index: 8
Max: 1.117507 index: 3
Max: 1.116891 index: 2
Max: 1.101853 index: 1
Max: 1.065814 index: 4
---------------------
Max: 1.479955 index: 2
Max: 1.467493 index: 6
Max: 1.447886 index: 3
Max: 1.433527 index: 4
Max: 1.429452 index: 1
---------------------
Max: 1.666061 index: 11
Max: 1.610511 index: 2
Max: 1.554048 index: 8
Max: 1.524860 index: 1
Max: 1.502236 index: 4
```
对应转化为
```
8 3 2 1 4
2 6 3 4 1
11 2 8 1 4
```
每组内由小到大排序
```
1 2 3 4 8
1 2 3 4 6
1 2 4 8 11
```
仅保留每组最大的三个序号
```
3 4 8
3 4 6
4 8 11
```
则本次输入为
```
3.0, 4.0, 8.0, 3.0, 4.0, 6.0, 4.0, 8.0, 11.0
```

## 调用流程
1. 上述TOP5的方法也可改为以下套路：
   * * 每次FFT，将序号0-2置0，即
```
FFT_OUTPUT[0] = 0;
FFT_OUTPUT[1] = 0;
FFT_OUTPUT[2] = 0;
```
然后找取三次最大值得到Top3

2. 累计3次Top3序号，得到9个序号，作为输入
```
float input[9] = {3.0, 4.0, 8.0, 3.0, 4.0, 6.0, 4.0, 8.0, 11.0};
```

3. 参考calc.c中的main中实现，计算本次分类

4. 重复1-3，直到结束

5. 由于分类错误率20%，建议滑窗取3次得到三组分类结果，取众数作为最终分类结果（三二判决）
